
Imponator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000049e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000512  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000007  00802000  00802000  00000512  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000512  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000544  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000584  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003818  00000000  00000000  0000060c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002953  00000000  00000000  00003e24  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000875  00000000  00000000  00006777  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000014c  00000000  00000000  00006fec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000023a0  00000000  00000000  00007138  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000024d  00000000  00000000  000094d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000058  00000000  00000000  00009725  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
   8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
   c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  10:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  14:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  18:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  1c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  20:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  24:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  28:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  2c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  30:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  34:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  38:	0c 94 25 02 	jmp	0x44a	; 0x44a <__vector_14>
  3c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  40:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  44:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  48:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  4c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  50:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  54:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  58:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  5c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  60:	0c 94 76 01 	jmp	0x2ec	; 0x2ec <__vector_24>
  64:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  68:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  6c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  70:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  74:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  78:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  7c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  80:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  84:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  88:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  8c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  90:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  94:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  98:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  9c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  a0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  a4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  a8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  ac:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  b0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  b4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  b8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  bc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  c0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  c4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  c8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  cc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  d0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  d4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  d8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  dc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  e0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  e4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  e8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  ec:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  f0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  f4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  f8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
  fc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 100:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 104:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 108:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 10c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 110:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 114:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 118:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 11c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 120:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 124:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 128:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 12c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 130:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 134:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 138:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 13c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 140:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 144:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 148:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 14c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 150:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 154:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 158:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 15c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 160:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 164:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 168:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 16c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 170:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 174:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 178:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 17c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 180:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 184:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 188:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 18c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 190:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 194:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 198:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 19c:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1a0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1a4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1a8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1ac:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1b0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1b4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1b8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1bc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1c0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1c4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1c8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1cc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1d0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1d4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1d8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1dc:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1e0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1e4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1e8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1ec:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1f0:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1f4:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>
 1f8:	0c 94 1d 01 	jmp	0x23a	; 0x23a <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_copy_data>:
 208:	10 e2       	ldi	r17, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	ee e9       	ldi	r30, 0x9E	; 158
 210:	f4 e0       	ldi	r31, 0x04	; 4
 212:	00 e0       	ldi	r16, 0x00	; 0
 214:	0b bf       	out	0x3b, r16	; 59
 216:	02 c0       	rjmp	.+4      	; 0x21c <__do_copy_data+0x14>
 218:	07 90       	elpm	r0, Z+
 21a:	0d 92       	st	X+, r0
 21c:	a0 30       	cpi	r26, 0x00	; 0
 21e:	b1 07       	cpc	r27, r17
 220:	d9 f7       	brne	.-10     	; 0x218 <__do_copy_data+0x10>

00000222 <__do_clear_bss>:
 222:	20 e2       	ldi	r18, 0x20	; 32
 224:	a0 e0       	ldi	r26, 0x00	; 0
 226:	b0 e2       	ldi	r27, 0x20	; 32
 228:	01 c0       	rjmp	.+2      	; 0x22c <.do_clear_bss_start>

0000022a <.do_clear_bss_loop>:
 22a:	1d 92       	st	X+, r1

0000022c <.do_clear_bss_start>:
 22c:	a7 30       	cpi	r26, 0x07	; 7
 22e:	b2 07       	cpc	r27, r18
 230:	e1 f7       	brne	.-8      	; 0x22a <.do_clear_bss_loop>
 232:	0e 94 2d 01 	call	0x25a	; 0x25a <main>
 236:	0c 94 4d 02 	jmp	0x49a	; 0x49a <_exit>

0000023a <__bad_interrupt>:
 23a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000023e <clock_init>:
		_delay_us(50);*/
    }
}

void clock_init(){
	OSC.CTRL |= OSC_RC32MEN_bm;
 23e:	e0 e5       	ldi	r30, 0x50	; 80
 240:	f0 e0       	ldi	r31, 0x00	; 0
 242:	80 81       	ld	r24, Z
 244:	82 60       	ori	r24, 0x02	; 2
 246:	80 83       	st	Z, r24
	while(!(OSC.STATUS & OSC_RC32MRDY_bm));
 248:	81 81       	ldd	r24, Z+1	; 0x01
 24a:	81 ff       	sbrs	r24, 1
 24c:	fd cf       	rjmp	.-6      	; 0x248 <clock_init+0xa>
	_PROTECTED_WRITE(CLK_CTRL, CLK_SCLKSEL_RC32M_gc);
 24e:	91 e0       	ldi	r25, 0x01	; 1
 250:	88 ed       	ldi	r24, 0xD8	; 216
 252:	84 bf       	out	0x34, r24	; 52
 254:	90 93 40 00 	sts	0x0040, r25	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
 258:	08 95       	ret

0000025a <main>:

void clock_init(void);

int main(void)
{
	clock_init();
 25a:	0e 94 1f 01 	call	0x23e	; 0x23e <clock_init>
	SPI_init();
 25e:	0e 94 41 01 	call	0x282	; 0x282 <SPI_init>
	Timer0_init();
 262:	0e 94 1b 02 	call	0x436	; 0x436 <Timer0_init>
	
	
	
	
	PORTA.DIRSET = 0b11111111; //ROW2
 266:	e0 e0       	ldi	r30, 0x00	; 0
 268:	f6 e0       	ldi	r31, 0x06	; 6
 26a:	8f ef       	ldi	r24, 0xFF	; 255
 26c:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTSET = 0b00000000; //ROW2
 26e:	15 82       	std	Z+5, r1	; 0x05
	SPIC.DATA = 0b11111111;
 270:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	
	sei();
 274:	78 94       	sei
	PMIC.CTRL |= 7; //all interrupt levels are enabled
 276:	e0 ea       	ldi	r30, 0xA0	; 160
 278:	f0 e0       	ldi	r31, 0x00	; 0
 27a:	82 81       	ldd	r24, Z+2	; 0x02
 27c:	87 60       	ori	r24, 0x07	; 7
 27e:	82 83       	std	Z+2, r24	; 0x02
 280:	ff cf       	rjmp	.-2      	; 0x280 <main+0x26>

00000282 <SPI_init>:
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};


void SPI_init(void){
	PORTC.DIRSET |= 1 << 0; //Latch pin for TLC5947
 282:	e0 e4       	ldi	r30, 0x40	; 64
 284:	f6 e0       	ldi	r31, 0x06	; 6
 286:	81 81       	ldd	r24, Z+1	; 0x01
 288:	81 60       	ori	r24, 0x01	; 1
 28a:	81 83       	std	Z+1, r24	; 0x01
	PORTC.DIRSET |= 1 << 1; //BLANK pin for TLC5947
 28c:	81 81       	ldd	r24, Z+1	; 0x01
 28e:	82 60       	ori	r24, 0x02	; 2
 290:	81 83       	std	Z+1, r24	; 0x01
	PORTC.DIRSET |= 1 << 7; //SCK pin for TLC5947
 292:	81 81       	ldd	r24, Z+1	; 0x01
 294:	80 68       	ori	r24, 0x80	; 128
 296:	81 83       	std	Z+1, r24	; 0x01
	PORTC.DIRSET |= 1 << 5; //MOSI pin for TLC5947
 298:	81 81       	ldd	r24, Z+1	; 0x01
 29a:	80 62       	ori	r24, 0x20	; 32
 29c:	81 83       	std	Z+1, r24	; 0x01


	PORTC.PIN4CTRL |= PORT_OPC_PULLUP_gc;
 29e:	84 89       	ldd	r24, Z+20	; 0x14
 2a0:	88 61       	ori	r24, 0x18	; 24
 2a2:	84 8b       	std	Z+20, r24	; 0x14
	PORTC.DIRSET |= 1 << 4; //Slave select
 2a4:	81 81       	ldd	r24, Z+1	; 0x01
 2a6:	80 61       	ori	r24, 0x10	; 16
 2a8:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET |= 1 << 4; //Slave select HIGH
 2aa:	85 81       	ldd	r24, Z+5	; 0x05
 2ac:	80 61       	ori	r24, 0x10	; 16
 2ae:	85 83       	std	Z+5, r24	; 0x05
	

	SPIC.CTRL |= SPI_ENABLE_bm | SPI_MASTER_bm | SPI_MODE_0_gc | SPI_PRESCALER_DIV128_gc | SPI_CLK2X_bm;
 2b0:	a0 ec       	ldi	r26, 0xC0	; 192
 2b2:	b8 e0       	ldi	r27, 0x08	; 8
 2b4:	8c 91       	ld	r24, X
 2b6:	83 6d       	ori	r24, 0xD3	; 211
 2b8:	8c 93       	st	X, r24
	SPIC.INTCTRL |= SPI_INTLVL_LO_gc;
 2ba:	11 96       	adiw	r26, 0x01	; 1
 2bc:	8c 91       	ld	r24, X
 2be:	11 97       	sbiw	r26, 0x01	; 1
 2c0:	81 60       	ori	r24, 0x01	; 1
 2c2:	11 96       	adiw	r26, 0x01	; 1
 2c4:	8c 93       	st	X, r24
	//SPIC.INTCTRL |= SPI_INTLVL_OFF_gc;
	
	PORTC.OUTCLR |= 1 << 0;
 2c6:	86 81       	ldd	r24, Z+6	; 0x06
 2c8:	81 60       	ori	r24, 0x01	; 1
 2ca:	86 83       	std	Z+6, r24	; 0x06
 2cc:	08 95       	ret

000002ce <SPI_update>:
}

void SPI_update(void){
	SPIC.INTCTRL |= SPI_INTLVL_MED_gc; // interrupt level for SPIC set to medium
 2ce:	e0 ec       	ldi	r30, 0xC0	; 192
 2d0:	f8 e0       	ldi	r31, 0x08	; 8
 2d2:	81 81       	ldd	r24, Z+1	; 0x01
 2d4:	82 60       	ori	r24, 0x02	; 2
 2d6:	81 83       	std	Z+1, r24	; 0x01
 2d8:	08 95       	ret

000002da <SPI_blankAndLatch>:
}

void SPI_blankAndLatch(void){
	PORTC.OUTSET |= 1 << 0 | 1<<1;
 2da:	e0 e4       	ldi	r30, 0x40	; 64
 2dc:	f6 e0       	ldi	r31, 0x06	; 6
 2de:	85 81       	ldd	r24, Z+5	; 0x05
 2e0:	83 60       	ori	r24, 0x03	; 3
 2e2:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTCLR |= 1 << 0 | 1<<1;
 2e4:	86 81       	ldd	r24, Z+6	; 0x06
 2e6:	83 60       	ori	r24, 0x03	; 3
 2e8:	86 83       	std	Z+6, r24	; 0x06
 2ea:	08 95       	ret

000002ec <__vector_24>:
}

ISR ( SPIC_INT_vect )
{
 2ec:	1f 92       	push	r1
 2ee:	0f 92       	push	r0
 2f0:	0f b6       	in	r0, 0x3f	; 63
 2f2:	0f 92       	push	r0
 2f4:	11 24       	eor	r1, r1
 2f6:	0b b6       	in	r0, 0x3b	; 59
 2f8:	0f 92       	push	r0
 2fa:	2f 93       	push	r18
 2fc:	3f 93       	push	r19
 2fe:	4f 93       	push	r20
 300:	5f 93       	push	r21
 302:	6f 93       	push	r22
 304:	7f 93       	push	r23
 306:	8f 93       	push	r24
 308:	9f 93       	push	r25
 30a:	af 93       	push	r26
 30c:	bf 93       	push	r27
 30e:	ef 93       	push	r30
 310:	ff 93       	push	r31
	The data is sent in batches of two 12bits variables, divided into three 8bits variables. ( 12*2 == 8*3 )
	The sending of the two 12bits variables are divied into three actions, each one choosing the appropriate bits
	to put into the 8bit variable c, which is transmitted once the switch ends.
*/
	
	switch ( _8bytesSent % 3 )			
 312:	90 91 06 20 	lds	r25, 0x2006	; 0x802006 <_8bytesSent.4607>
 316:	8b ea       	ldi	r24, 0xAB	; 171
 318:	98 9f       	mul	r25, r24
 31a:	81 2d       	mov	r24, r1
 31c:	11 24       	eor	r1, r1
 31e:	86 95       	lsr	r24
 320:	28 2f       	mov	r18, r24
 322:	22 0f       	add	r18, r18
 324:	82 0f       	add	r24, r18
 326:	29 2f       	mov	r18, r25
 328:	28 1b       	sub	r18, r24
 32a:	21 30       	cpi	r18, 0x01	; 1
 32c:	01 f1       	breq	.+64     	; 0x36e <__vector_24+0x82>
 32e:	18 f0       	brcs	.+6      	; 0x336 <__vector_24+0x4a>
 330:	22 30       	cpi	r18, 0x02	; 2
 332:	e9 f1       	breq	.+122    	; 0x3ae <__vector_24+0xc2>
 334:	44 c0       	rjmp	.+136    	; 0x3be <__vector_24+0xd2>
	{
		case ( 0 ):
			if(row == 0 || row==5)
 336:	80 91 05 20 	lds	r24, 0x2005	; 0x802005 <row.4608>
 33a:	88 23       	and	r24, r24
 33c:	11 f0       	breq	.+4      	; 0x342 <__vector_24+0x56>
 33e:	85 30       	cpi	r24, 0x05	; 5
 340:	39 f4       	brne	.+14     	; 0x350 <__vector_24+0x64>
				first12Bits = 0b11111111;
 342:	2f ef       	ldi	r18, 0xFF	; 255
 344:	30 e0       	ldi	r19, 0x00	; 0
 346:	20 93 03 20 	sts	0x2003, r18	; 0x802003 <first12Bits.4609>
 34a:	30 93 04 20 	sts	0x2004, r19	; 0x802004 <first12Bits.4609+0x1>
 34e:	04 c0       	rjmp	.+8      	; 0x358 <__vector_24+0x6c>
			else first12Bits = 0b00000000;
 350:	10 92 03 20 	sts	0x2003, r1	; 0x802003 <first12Bits.4609>
 354:	10 92 04 20 	sts	0x2004, r1	; 0x802004 <first12Bits.4609+0x1>
			c = ( uint8_t ) (first12Bits >> 4);
 358:	20 91 03 20 	lds	r18, 0x2003	; 0x802003 <first12Bits.4609>
 35c:	30 91 04 20 	lds	r19, 0x2004	; 0x802004 <first12Bits.4609+0x1>
 360:	32 95       	swap	r19
 362:	22 95       	swap	r18
 364:	2f 70       	andi	r18, 0x0F	; 15
 366:	23 27       	eor	r18, r19
 368:	3f 70       	andi	r19, 0x0F	; 15
 36a:	23 27       	eor	r18, r19
			
			break;
 36c:	29 c0       	rjmp	.+82     	; 0x3c0 <__vector_24+0xd4>
	
		// case 0: read out the 16bits value from the lookupTable. Send MSB
	

		case( 1 ):
			if(row == 0 || row == 5)
 36e:	80 91 05 20 	lds	r24, 0x2005	; 0x802005 <row.4608>
 372:	88 23       	and	r24, r24
 374:	11 f0       	breq	.+4      	; 0x37a <__vector_24+0x8e>
 376:	85 30       	cpi	r24, 0x05	; 5
 378:	39 f4       	brne	.+14     	; 0x388 <__vector_24+0x9c>
				second12Bits = 0b11111111;
 37a:	2f ef       	ldi	r18, 0xFF	; 255
 37c:	30 e0       	ldi	r19, 0x00	; 0
 37e:	20 93 01 20 	sts	0x2001, r18	; 0x802001 <second12Bits.4610>
 382:	30 93 02 20 	sts	0x2002, r19	; 0x802002 <second12Bits.4610+0x1>
 386:	04 c0       	rjmp	.+8      	; 0x390 <__vector_24+0xa4>
			else second12Bits = 0b00000000;
 388:	10 92 01 20 	sts	0x2001, r1	; 0x802001 <second12Bits.4610>
 38c:	10 92 02 20 	sts	0x2002, r1	; 0x802002 <second12Bits.4610+0x1>
			++_12bytesSent;
 390:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_end>
 394:	8f 5f       	subi	r24, 0xFF	; 255
 396:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_end>
			c = (uint8_t) ( first12Bits << 4 );
 39a:	20 91 03 20 	lds	r18, 0x2003	; 0x802003 <first12Bits.4609>
 39e:	82 2f       	mov	r24, r18
 3a0:	82 95       	swap	r24
 3a2:	80 7f       	andi	r24, 0xF0	; 240
			MSB_filter_var = ((uint8_t) ( second12Bits >> 8 ))  & 0x0F;
			c |= MSB_filter_var;
 3a4:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <second12Bits.4610+0x1>
 3a8:	2f 70       	andi	r18, 0x0F	; 15
 3aa:	28 2b       	or	r18, r24
			
			break;
 3ac:	09 c0       	rjmp	.+18     	; 0x3c0 <__vector_24+0xd4>
				The MSB_filter_var eliminates these bits away.
		*/
			
		case( 2 ):
		
			c = (uint8_t) second12Bits;
 3ae:	20 91 01 20 	lds	r18, 0x2001	; 0x802001 <second12Bits.4610>
			_12bytesSent++;
 3b2:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_end>
 3b6:	8f 5f       	subi	r24, 0xFF	; 255
 3b8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_end>
			break;
 3bc:	01 c0       	rjmp	.+2      	; 0x3c0 <__vector_24+0xd4>
	static uint8_t		row				= 0;
	
	static uint16_t		first12Bits		= 0;
	static uint16_t		second12Bits	= 0;
	
	uint8_t				c				= 0;
 3be:	20 e0       	ldi	r18, 0x00	; 0
		break;
		
		
		}
		
		SPIC.DATA = c;                  // send data
 3c0:	20 93 c3 08 	sts	0x08C3, r18	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
		_8bytesSent++;
 3c4:	9f 5f       	subi	r25, 0xFF	; 255
 3c6:	90 93 06 20 	sts	0x2006, r25	; 0x802006 <_8bytesSent.4607>
		
		if ( _12bytesSent > 24  || _8bytesSent > 36 )					// if reached end
 3ca:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_end>
 3ce:	89 31       	cpi	r24, 0x19	; 25
 3d0:	10 f4       	brcc	.+4      	; 0x3d6 <__vector_24+0xea>
 3d2:	95 32       	cpi	r25, 0x25	; 37
 3d4:	e8 f0       	brcs	.+58     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		{
			
			SPI_blankAndLatch();
 3d6:	0e 94 6d 01 	call	0x2da	; 0x2da <SPI_blankAndLatch>
			
			SPIC.INTCTRL	&=		~( ( 1 << 0 ) | ( 1 << 1 ) );		// turn off interrupts
 3da:	e0 ec       	ldi	r30, 0xC0	; 192
 3dc:	f8 e0       	ldi	r31, 0x08	; 8
 3de:	81 81       	ldd	r24, Z+1	; 0x01
 3e0:	8c 7f       	andi	r24, 0xFC	; 252
 3e2:	81 83       	std	Z+1, r24	; 0x01
			_12bytesSent	=		0;
 3e4:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <__data_end>
			_8bytesSent		=		0;
 3e8:	10 92 06 20 	sts	0x2006, r1	; 0x802006 <_8bytesSent.4607>
			
			
			if(++row > 7){
 3ec:	80 91 05 20 	lds	r24, 0x2005	; 0x802005 <row.4608>
 3f0:	8f 5f       	subi	r24, 0xFF	; 255
 3f2:	80 93 05 20 	sts	0x2005, r24	; 0x802005 <row.4608>
 3f6:	88 30       	cpi	r24, 0x08	; 8
 3f8:	30 f0       	brcs	.+12     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
				row = 0;
 3fa:	10 92 05 20 	sts	0x2005, r1	; 0x802005 <row.4608>
				PORTA.OUT=1;
 3fe:	81 e0       	ldi	r24, 0x01	; 1
 400:	80 93 04 06 	sts	0x0604, r24	; 0x800604 <__TEXT_REGION_LENGTH__+0x700604>
 404:	05 c0       	rjmp	.+10     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
			}
			else PORTA.OUT= PORTA.OUT << 1;
 406:	e0 e0       	ldi	r30, 0x00	; 0
 408:	f6 e0       	ldi	r31, 0x06	; 6
 40a:	84 81       	ldd	r24, Z+4	; 0x04
 40c:	88 0f       	add	r24, r24
 40e:	84 83       	std	Z+4, r24	; 0x04
			
		}	
}
 410:	ff 91       	pop	r31
 412:	ef 91       	pop	r30
 414:	bf 91       	pop	r27
 416:	af 91       	pop	r26
 418:	9f 91       	pop	r25
 41a:	8f 91       	pop	r24
 41c:	7f 91       	pop	r23
 41e:	6f 91       	pop	r22
 420:	5f 91       	pop	r21
 422:	4f 91       	pop	r20
 424:	3f 91       	pop	r19
 426:	2f 91       	pop	r18
 428:	0f 90       	pop	r0
 42a:	0b be       	out	0x3b, r0	; 59
 42c:	0f 90       	pop	r0
 42e:	0f be       	out	0x3f, r0	; 63
 430:	0f 90       	pop	r0
 432:	1f 90       	pop	r1
 434:	18 95       	reti

00000436 <Timer0_init>:
#include "SPI.h"

uint8_t ranForFirstTime = 0;
void Timer0_init(void)
{
	TCC0.CTRLA = 0b00000011; //PRESCALER CLK_DIV4
 436:	e0 e0       	ldi	r30, 0x00	; 0
 438:	f8 e0       	ldi	r31, 0x08	; 8
 43a:	83 e0       	ldi	r24, 0x03	; 3
 43c:	80 83       	st	Z, r24
	TCC0.INTCTRLA = 0b00000011; //Interrupt level HIGH
 43e:	86 83       	std	Z+6, r24	; 0x06
	TCC0.PER = 5000;
 440:	88 e8       	ldi	r24, 0x88	; 136
 442:	93 e1       	ldi	r25, 0x13	; 19
 444:	86 a3       	std	Z+38, r24	; 0x26
 446:	97 a3       	std	Z+39, r25	; 0x27
 448:	08 95       	ret

0000044a <__vector_14>:
}
/*		Timer 0 is used for the periodic update of the Display		*/

ISR ( TCC0_OVF_vect )
{
 44a:	1f 92       	push	r1
 44c:	0f 92       	push	r0
 44e:	0f b6       	in	r0, 0x3f	; 63
 450:	0f 92       	push	r0
 452:	11 24       	eor	r1, r1
 454:	0b b6       	in	r0, 0x3b	; 59
 456:	0f 92       	push	r0
 458:	2f 93       	push	r18
 45a:	3f 93       	push	r19
 45c:	4f 93       	push	r20
 45e:	5f 93       	push	r21
 460:	6f 93       	push	r22
 462:	7f 93       	push	r23
 464:	8f 93       	push	r24
 466:	9f 93       	push	r25
 468:	af 93       	push	r26
 46a:	bf 93       	push	r27
 46c:	ef 93       	push	r30
 46e:	ff 93       	push	r31
	SPI_update();
 470:	0e 94 67 01 	call	0x2ce	; 0x2ce <SPI_update>
 474:	ff 91       	pop	r31
 476:	ef 91       	pop	r30
 478:	bf 91       	pop	r27
 47a:	af 91       	pop	r26
 47c:	9f 91       	pop	r25
 47e:	8f 91       	pop	r24
 480:	7f 91       	pop	r23
 482:	6f 91       	pop	r22
 484:	5f 91       	pop	r21
 486:	4f 91       	pop	r20
 488:	3f 91       	pop	r19
 48a:	2f 91       	pop	r18
 48c:	0f 90       	pop	r0
 48e:	0b be       	out	0x3b, r0	; 59
 490:	0f 90       	pop	r0
 492:	0f be       	out	0x3f, r0	; 63
 494:	0f 90       	pop	r0
 496:	1f 90       	pop	r1
 498:	18 95       	reti

0000049a <_exit>:
 49a:	f8 94       	cli

0000049c <__stop_program>:
 49c:	ff cf       	rjmp	.-2      	; 0x49c <__stop_program>
